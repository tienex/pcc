/*
 * C# Runtime - Async/Await Implementation
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include "../include/csruntime.h"

/* Task thread pool */
#define MAX_WORKER_THREADS 8
static pthread_t worker_threads[MAX_WORKER_THREADS];
static int thread_pool_initialized = 0;

/* Task queue */
#define MAX_TASK_QUEUE 256
typedef struct {
	CSTask *tasks[MAX_TASK_QUEUE];
	int head;
	int tail;
	int count;
	pthread_mutex_t mutex;
	pthread_cond_t cond;
	int shutdown;
} TaskQueue;

static TaskQueue task_queue = {
	.head = 0,
	.tail = 0,
	.count = 0,
	.mutex = PTHREAD_MUTEX_INITIALIZER,
	.cond = PTHREAD_COND_INITIALIZER,
	.shutdown = 0,
};

/* ========== Task Queue Operations ========== */

static void task_queue_push(CSTask *task) {
	pthread_mutex_lock(&task_queue.mutex);

	if (task_queue.count < MAX_TASK_QUEUE) {
		task_queue.tasks[task_queue.tail] = task;
		task_queue.tail = (task_queue.tail + 1) % MAX_TASK_QUEUE;
		task_queue.count++;
		pthread_cond_signal(&task_queue.cond);
	}

	pthread_mutex_unlock(&task_queue.mutex);
}

static CSTask *task_queue_pop(void) {
	pthread_mutex_lock(&task_queue.mutex);

	while (task_queue.count == 0 && !task_queue.shutdown) {
		pthread_cond_wait(&task_queue.cond, &task_queue.mutex);
	}

	if (task_queue.shutdown) {
		pthread_mutex_unlock(&task_queue.mutex);
		return NULL;
	}

	CSTask *task = task_queue.tasks[task_queue.head];
	task_queue.head = (task_queue.head + 1) % MAX_TASK_QUEUE;
	task_queue.count--;

	pthread_mutex_unlock(&task_queue.mutex);

	return task;
}

/* ========== Worker Thread ========== */

static void *worker_thread_func(void *arg) {
	while (1) {
		CSTask *task = task_queue_pop();
		if (!task) break; /* Shutdown */

		/* Execute task */
		task->status = CS_TASK_RUNNING;

		/* For simplified implementation, just mark as completed */
		task->status = CS_TASK_RAN_TO_COMPLETION;
		task->is_completed = 1;

		/* Call continuation if set */
		if (task->continuation) {
			task->continuation(task);
		}
	}

	return NULL;
}

static void init_thread_pool(void) {
	if (thread_pool_initialized) return;

	for (int i = 0; i < MAX_WORKER_THREADS; i++) {
		pthread_create(&worker_threads[i], NULL, worker_thread_func, NULL);
	}

	thread_pool_initialized = 1;
}

/* ========== Task<T> Operations ========== */

CSTask *CS_Task_Create(void (*action)(void *), void *state) {
	CSTask *task = (CSTask *)CS_AllocObject(sizeof(CSTask), 1);
	if (!task) return NULL;

	task->status = CS_TASK_CREATED;
	task->result = NULL;
	task->result_type = NULL;
	task->exception = NULL;
	task->is_completed = 0;
	task->is_canceled = 0;
	task->is_faulted = 0;
	task->continuation = NULL;
	task->continuation_task = NULL;

	return task;
}

CSTask *CS_Task_CreateWithResult(void *(*func)(void *), void *state,
                                  CSTypeInfo *result_type) {
	CSTask *task = (CSTask *)CS_AllocObject(sizeof(CSTask), 1);
	if (!task) return NULL;

	task->status = CS_TASK_CREATED;
	task->result = NULL;
	task->result_type = result_type;
	task->exception = NULL;
	task->is_completed = 0;
	task->is_canceled = 0;
	task->is_faulted = 0;
	task->continuation = NULL;
	task->continuation_task = NULL;

	return task;
}

void CS_Task_Start(CSTask *task) {
	if (!task) return;

	init_thread_pool();

	task->status = CS_TASK_WAITING_TO_RUN;
	task_queue_push(task);
}

void CS_Task_Wait(CSTask *task) {
	if (!task) return;

	/* Simplified - busy wait until completed */
	while (!task->is_completed) {
		usleep(1000); /* Sleep 1ms */
	}
}

CSBool CS_Task_WaitTimeout(CSTask *task, int32_t milliseconds) {
	if (!task) return 0;

	int32_t elapsed = 0;
	while (!task->is_completed && elapsed < milliseconds) {
		usleep(1000); /* Sleep 1ms */
		elapsed++;
	}

	return task->is_completed;
}

void *CS_Task_GetResult(CSTask *task) {
	if (!task) return NULL;

	CS_Task_Wait(task);

	if (task->is_faulted) {
		/* Would throw exception */
		return NULL;
	}

	return task->result;
}

/* ========== Async State Machine ========== */

CSAsyncStateMachine *CS_AsyncStateMachine_Create(void) {
	CSAsyncStateMachine *sm = (CSAsyncStateMachine *)CS_Malloc(sizeof(CSAsyncStateMachine));
	if (!sm) return NULL;

	sm->state = 0;
	sm->builder = NULL;
	sm->local_vars = NULL;
	sm->awaiter = NULL;

	return sm;
}

void CS_AsyncStateMachine_MoveNext(CSAsyncStateMachine *sm) {
	if (!sm) return;

	/* State machine execution - would be generated by compiler */
	/* Simplified implementation */
}

void CS_AsyncStateMachine_SetResult(CSAsyncStateMachine *sm, void *result) {
	if (!sm || !sm->builder) return;

	CS_AsyncTaskMethodBuilder_SetResult((CSAsyncTaskMethodBuilder *)sm->builder, result);
}

void CS_AsyncStateMachine_SetException(CSAsyncStateMachine *sm, void *exception) {
	if (!sm || !sm->builder) return;

	CS_AsyncTaskMethodBuilder_SetException((CSAsyncTaskMethodBuilder *)sm->builder, exception);
}

/* ========== Awaiter Interface ========== */

CSBool CS_Awaiter_IsCompleted(CSAwaiter *awaiter) {
	if (!awaiter || !awaiter->vtable || !awaiter->vtable->IsCompleted) {
		return 0;
	}

	return awaiter->vtable->IsCompleted(awaiter);
}

void *CS_Awaiter_GetResult(CSAwaiter *awaiter) {
	if (!awaiter || !awaiter->vtable || !awaiter->vtable->GetResult) {
		return NULL;
	}

	return awaiter->vtable->GetResult(awaiter);
}

void CS_Awaiter_OnCompleted(CSAwaiter *awaiter, void (*continuation)(void)) {
	if (!awaiter || !awaiter->vtable || !awaiter->vtable->OnCompleted) {
		return;
	}

	awaiter->vtable->OnCompleted(awaiter, continuation);
}

/* ========== Task Completion Source ========== */

CSTaskCompletionSource *CS_TaskCompletionSource_Create(CSTypeInfo *result_type) {
	CSTaskCompletionSource *tcs = (CSTaskCompletionSource *)CS_AllocObject(
	    sizeof(CSTaskCompletionSource), 1);
	if (!tcs) return NULL;

	tcs->task = CS_Task_CreateWithResult(NULL, NULL, result_type);
	if (!tcs->task) {
		CS_Release((CSObject *)tcs);
		return NULL;
	}

	return tcs;
}

void CS_TaskCompletionSource_SetResult(CSTaskCompletionSource *tcs,
                                        void *result) {
	if (!tcs || !tcs->task) return;

	tcs->task->result = result;
	tcs->task->status = CS_TASK_RAN_TO_COMPLETION;
	tcs->task->is_completed = 1;

	/* Call continuation if set */
	if (tcs->task->continuation) {
		tcs->task->continuation(tcs->task);
	}
}

void CS_TaskCompletionSource_SetException(CSTaskCompletionSource *tcs,
                                          void *exception) {
	if (!tcs || !tcs->task) return;

	tcs->task->exception = exception;
	tcs->task->status = CS_TASK_FAULTED;
	tcs->task->is_faulted = 1;
	tcs->task->is_completed = 1;

	/* Call continuation if set */
	if (tcs->task->continuation) {
		tcs->task->continuation(tcs->task);
	}
}

void CS_TaskCompletionSource_SetCanceled(CSTaskCompletionSource *tcs) {
	if (!tcs || !tcs->task) return;

	tcs->task->status = CS_TASK_CANCELED;
	tcs->task->is_canceled = 1;
	tcs->task->is_completed = 1;

	/* Call continuation if set */
	if (tcs->task->continuation) {
		tcs->task->continuation(tcs->task);
	}
}

CSTask *CS_TaskCompletionSource_GetTask(CSTaskCompletionSource *tcs) {
	return tcs ? tcs->task : NULL;
}

/* ========== Task Combinators ========== */

static void when_all_check_completion(CSTask *task) {
	/* Would check if all tasks are completed and update result task */
}

CSTask *CS_Task_WhenAll(CSTask **tasks, int32_t count) {
	if (!tasks || count <= 0) return NULL;

	CSTask *result = CS_Task_Create(NULL, NULL);
	if (!result) return NULL;

	/* Simplified - would need to track completion of all tasks */
	result->status = CS_TASK_WAITING_FOR_CHILDREN;

	for (int32_t i = 0; i < count; i++) {
		if (tasks[i]) {
			tasks[i]->continuation = when_all_check_completion;
		}
	}

	return result;
}

CSTask *CS_Task_WhenAny(CSTask **tasks, int32_t count) {
	if (!tasks || count <= 0) return NULL;

	CSTask *result = CS_Task_Create(NULL, NULL);
	if (!result) return NULL;

	/* Simplified - would need to complete when first task completes */
	result->status = CS_TASK_WAITING_FOR_CHILDREN;

	return result;
}

static void *delay_thread(void *arg) {
	int32_t milliseconds = *(int32_t *)arg;
	usleep(milliseconds * 1000);

	CSTask *task = (CSTask *)arg;
	task->status = CS_TASK_RAN_TO_COMPLETION;
	task->is_completed = 1;

	return NULL;
}

CSTask *CS_Task_Delay(int32_t milliseconds) {
	CSTask *task = CS_Task_Create(NULL, NULL);
	if (!task) return NULL;

	/* Start delay in background thread */
	pthread_t thread;
	pthread_create(&thread, NULL, delay_thread, &milliseconds);
	pthread_detach(thread);

	return task;
}

CSTask *CS_Task_FromResult(void *result, CSTypeInfo *result_type) {
	CSTask *task = CS_Task_CreateWithResult(NULL, NULL, result_type);
	if (!task) return NULL;

	task->result = result;
	task->status = CS_TASK_RAN_TO_COMPLETION;
	task->is_completed = 1;

	return task;
}

CSTask *CS_Task_FromException(void *exception) {
	CSTask *task = CS_Task_Create(NULL, NULL);
	if (!task) return NULL;

	task->exception = exception;
	task->status = CS_TASK_FAULTED;
	task->is_faulted = 1;
	task->is_completed = 1;

	return task;
}

CSTask *CS_Task_CompletedTask(void) {
	static CSTask *completed_task = NULL;

	if (!completed_task) {
		completed_task = CS_Task_Create(NULL, NULL);
		if (completed_task) {
			completed_task->status = CS_TASK_RAN_TO_COMPLETION;
			completed_task->is_completed = 1;
		}
	}

	return completed_task;
}

/* ========== Async Method Builder ========== */

CSAsyncTaskMethodBuilder *CS_AsyncTaskMethodBuilder_Create(void) {
	CSAsyncTaskMethodBuilder *builder = (CSAsyncTaskMethodBuilder *)CS_Malloc(
	    sizeof(CSAsyncTaskMethodBuilder));
	if (!builder) return NULL;

	builder->task = CS_Task_Create(NULL, NULL);
	builder->state_machine = NULL;

	return builder;
}

void CS_AsyncTaskMethodBuilder_Start(CSAsyncTaskMethodBuilder *builder,
                                     CSAsyncStateMachine *sm) {
	if (!builder || !sm) return;

	builder->state_machine = sm;
	sm->builder = builder;

	/* Start state machine */
	CS_AsyncStateMachine_MoveNext(sm);
}

void CS_AsyncTaskMethodBuilder_SetResult(CSAsyncTaskMethodBuilder *builder,
                                         void *result) {
	if (!builder || !builder->task) return;

	builder->task->result = result;
	builder->task->status = CS_TASK_RAN_TO_COMPLETION;
	builder->task->is_completed = 1;

	if (builder->task->continuation) {
		builder->task->continuation(builder->task);
	}
}

void CS_AsyncTaskMethodBuilder_SetException(CSAsyncTaskMethodBuilder *builder,
                                            void *exception) {
	if (!builder || !builder->task) return;

	builder->task->exception = exception;
	builder->task->status = CS_TASK_FAULTED;
	builder->task->is_faulted = 1;
	builder->task->is_completed = 1;

	if (builder->task->continuation) {
		builder->task->continuation(builder->task);
	}
}

void CS_AsyncTaskMethodBuilder_AwaitUnsafeOnCompleted(
    CSAsyncTaskMethodBuilder *builder,
    CSAwaiter *awaiter,
    CSAsyncStateMachine *sm) {
	if (!builder || !awaiter || !sm) return;

	/* Set up continuation to resume state machine */
	/* Simplified implementation */
}

CSTask *CS_AsyncTaskMethodBuilder_GetTask(CSAsyncTaskMethodBuilder *builder) {
	return builder ? builder->task : NULL;
}

/* ========== ValueTask Support ========== */

CSValueTask *CS_ValueTask_Create(void *value) {
	CSValueTask *vt = (CSValueTask *)CS_AllocObject(sizeof(CSValueTask), 1);
	if (!vt) return NULL;

	vt->has_value = 1;
	vt->value = value;
	vt->task = NULL;

	return vt;
}

CSValueTask *CS_ValueTask_FromTask(CSTask *task) {
	CSValueTask *vt = (CSValueTask *)CS_AllocObject(sizeof(CSValueTask), 1);
	if (!vt) return NULL;

	vt->has_value = 0;
	vt->value = NULL;
	vt->task = task;

	return vt;
}

CSBool CS_ValueTask_IsCompleted(CSValueTask *vt) {
	if (!vt) return 0;

	if (vt->has_value) {
		return 1;
	}

	return vt->task ? vt->task->is_completed : 0;
}

void *CS_ValueTask_GetResult(CSValueTask *vt) {
	if (!vt) return NULL;

	if (vt->has_value) {
		return vt->value;
	}

	return vt->task ? CS_Task_GetResult(vt->task) : NULL;
}
