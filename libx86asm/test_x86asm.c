/*
 * test_x86asm.c - Test suite for x86 assembly emitter library
 *
 * Copyright (c) 2025
 * BSD Licensed - See COPYING
 *
 * Demonstrates usage of all supported assembler formats
 */

#include "x86asm.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * Test helper: Generate a simple function across all formats
 */
static void
test_simple_function(x86asm_format_t format, const char *format_name, int bits)
{
    char filename[256];
    FILE *fp;
    x86asm_ctx_t *ctx;

    snprintf(filename, sizeof(filename), "test_output_%s_%d.asm", format_name, bits);
    fp = fopen(filename, "w");
    if (!fp) {
        fprintf(stderr, "Failed to open %s\n", filename);
        return;
    }

    ctx = x86asm_create(format, fp, bits);
    if (!ctx) {
        fprintf(stderr, "Failed to create context for %s\n", format_name);
        fclose(fp);
        return;
    }

    /* Add a comment header */
    x86asm_comment(ctx, "==============================================");
    x86asm_comment(ctx, "Test function generated by x86asm library");
    x86asm_comment(ctx, format_name);
    x86asm_comment(ctx, "==============================================");

    /* Code section */
    x86asm_segment(ctx, SEG_TEXT, NULL);

    /* Function: int add_numbers(int a, int b) */
    x86asm_label(ctx, "add_numbers", 1);

    if (bits == 32) {
        /* 32-bit calling convention */
        x86asm_comment(ctx, "Function prologue");
        X86ASM_INSN1(ctx, "push", x86asm_op_reg(REG_EBP, 32));
        X86ASM_INSN2(ctx, "mov", x86asm_op_reg(REG_EBP, 32), x86asm_op_reg(REG_ESP, 32));

        x86asm_comment(ctx, "Load arguments and add");
        X86ASM_INSN2(ctx, "mov", x86asm_op_reg(REG_EAX, 32),
                     x86asm_op_mem(REG_EBP, REG_NONE, 0, 8, 32));
        X86ASM_INSN2(ctx, "add", x86asm_op_reg(REG_EAX, 32),
                     x86asm_op_mem(REG_EBP, REG_NONE, 0, 12, 32));

        x86asm_comment(ctx, "Function epilogue");
        X86ASM_INSN1(ctx, "pop", x86asm_op_reg(REG_EBP, 32));
        X86ASM_INSN0(ctx, "ret");

    } else if (bits == 64) {
        /* 64-bit calling convention (System V AMD64 ABI) */
        x86asm_comment(ctx, "Arguments in RDI and RSI");
        X86ASM_INSN2(ctx, "mov", x86asm_op_reg(REG_RAX, 64), x86asm_op_reg(REG_RDI, 64));
        X86ASM_INSN2(ctx, "add", x86asm_op_reg(REG_RAX, 64), x86asm_op_reg(REG_RSI, 64));
        X86ASM_INSN0(ctx, "ret");
    }

    /* Data section */
    x86asm_segment(ctx, SEG_DATA, NULL);

    x86asm_comment(ctx, "Data section");
    x86asm_label(ctx, "message", 0);
    const char *msg = "Hello from x86asm!";
    x86asm_data(ctx, DATA_ASCIZ, msg, strlen(msg));

    x86asm_label(ctx, "numbers", 0);
    uint32_t numbers[] = {1, 2, 3, 4, 5};
    x86asm_data(ctx, DATA_DWORD, numbers, 5);

    /* Read-only data section */
    x86asm_segment(ctx, SEG_RODATA, NULL);

    x86asm_label(ctx, "pi_approx", 0);
    uint32_t pi = 0x40490FDB;  /* float representation of ~3.14159 */
    x86asm_data(ctx, DATA_DWORD, &pi, 1);

    /* Cleanup */
    x86asm_destroy(ctx);
    fclose(fp);

    printf("Generated: %s\n", filename);
}

/*
 * Test complex addressing modes
 */
static void
test_complex_addressing(x86asm_format_t format, const char *format_name)
{
    char filename[256];
    FILE *fp;
    x86asm_ctx_t *ctx;

    snprintf(filename, sizeof(filename), "test_addressing_%s.asm", format_name);
    fp = fopen(filename, "w");
    if (!fp) {
        fprintf(stderr, "Failed to open %s\n", filename);
        return;
    }

    ctx = x86asm_create(format, fp, 64);
    if (!ctx) {
        fprintf(stderr, "Failed to create context for %s\n", format_name);
        fclose(fp);
        return;
    }

    x86asm_comment(ctx, "Complex addressing mode tests");
    x86asm_segment(ctx, SEG_TEXT, NULL);
    x86asm_label(ctx, "addressing_test", 1);

    /* Direct memory reference */
    x86asm_comment(ctx, "Direct memory reference");
    X86ASM_INSN2(ctx, "mov", x86asm_op_reg(REG_RAX, 64),
                 x86asm_op_mem_symbol("global_var", 0, 64));

    /* Base + displacement */
    x86asm_comment(ctx, "Base + displacement");
    X86ASM_INSN2(ctx, "mov", x86asm_op_reg(REG_RBX, 64),
                 x86asm_op_mem(REG_RBP, REG_NONE, 0, -16, 64));

    /* Base + index */
    x86asm_comment(ctx, "Base + index");
    X86ASM_INSN2(ctx, "mov", x86asm_op_reg(REG_RCX, 64),
                 x86asm_op_mem(REG_RAX, REG_RBX, 1, 0, 64));

    /* Base + index*scale + displacement */
    x86asm_comment(ctx, "Base + index*scale + displacement");
    X86ASM_INSN2(ctx, "mov", x86asm_op_reg(REG_RDX, 64),
                 x86asm_op_mem(REG_RSI, REG_RDI, 8, 32, 64));

    /* Immediate values */
    x86asm_comment(ctx, "Immediate values");
    X86ASM_INSN2(ctx, "mov", x86asm_op_reg(REG_R8, 64), x86asm_op_imm(0x1234, 64));
    X86ASM_INSN2(ctx, "add", x86asm_op_reg(REG_R9, 64), x86asm_op_imm(42, 64));

    X86ASM_INSN0(ctx, "ret");

    x86asm_destroy(ctx);
    fclose(fp);

    printf("Generated: %s\n", filename);
}

/*
 * Test SIMD instructions
 */
static void
test_simd_instructions(x86asm_format_t format, const char *format_name)
{
    char filename[256];
    FILE *fp;
    x86asm_ctx_t *ctx;

    snprintf(filename, sizeof(filename), "test_simd_%s.asm", format_name);
    fp = fopen(filename, "w");
    if (!fp) {
        fprintf(stderr, "Failed to open %s\n", filename);
        return;
    }

    ctx = x86asm_create(format, fp, 64);
    if (!ctx) {
        fprintf(stderr, "Failed to create context for %s\n", format_name);
        fclose(fp);
        return;
    }

    x86asm_comment(ctx, "SIMD instruction tests");
    x86asm_segment(ctx, SEG_TEXT, NULL);
    x86asm_label(ctx, "simd_test", 1);

    /* SSE instructions */
    x86asm_comment(ctx, "SSE instructions");
    X86ASM_INSN2(ctx, "movaps", x86asm_op_reg(REG_XMM0, 128),
                 x86asm_op_mem(REG_RAX, REG_NONE, 0, 0, 128));
    X86ASM_INSN2(ctx, "addps", x86asm_op_reg(REG_XMM1, 128),
                 x86asm_op_reg(REG_XMM0, 128));

    /* AVX instructions */
    x86asm_comment(ctx, "AVX instructions");
    X86ASM_INSN2(ctx, "vmovaps", x86asm_op_reg(REG_YMM0, 256),
                 x86asm_op_mem(REG_RBX, REG_NONE, 0, 0, 256));
    X86ASM_INSN2(ctx, "vaddps", x86asm_op_reg(REG_YMM1, 256),
                 x86asm_op_reg(REG_YMM0, 256));

    X86ASM_INSN0(ctx, "ret");

    x86asm_destroy(ctx);
    fclose(fp);

    printf("Generated: %s\n", filename);
}

/*
 * Main test driver
 */
int
main(int argc, char **argv)
{
    typedef struct {
        x86asm_format_t format;
        const char *name;
    } format_test_t;

    format_test_t formats[] = {
        { ASM_FMT_GNU_AS,   "gnu_as"   },
        { ASM_FMT_APPLE_AS, "apple_as" },
        { ASM_FMT_MASM,     "masm"     },
        { ASM_FMT_ML,       "ml"       },
        { ASM_FMT_TASM,     "tasm"     },
        { ASM_FMT_WASM,     "wasm"     },
        { ASM_FMT_OWASM,    "owasm"    },
        { ASM_FMT_NASM,     "nasm"     },
        { ASM_FMT_YASM,     "yasm"     }
    };

    int num_formats = sizeof(formats) / sizeof(formats[0]);
    int i;

    printf("x86asm library test suite\n");
    printf("==========================\n\n");

    /* Test simple functions for all formats */
    printf("Testing simple functions (32-bit):\n");
    for (i = 0; i < num_formats; i++) {
        test_simple_function(formats[i].format, formats[i].name, 32);
    }
    printf("\n");

    printf("Testing simple functions (64-bit):\n");
    for (i = 0; i < num_formats; i++) {
        test_simple_function(formats[i].format, formats[i].name, 64);
    }
    printf("\n");

    /* Test complex addressing modes */
    printf("Testing complex addressing modes:\n");
    for (i = 0; i < num_formats; i++) {
        test_complex_addressing(formats[i].format, formats[i].name);
    }
    printf("\n");

    /* Test SIMD instructions */
    printf("Testing SIMD instructions:\n");
    for (i = 0; i < num_formats; i++) {
        test_simd_instructions(formats[i].format, formats[i].name);
    }
    printf("\n");

    printf("All tests completed!\n");
    printf("Generated assembly files can be found in the current directory.\n");

    return 0;
}
