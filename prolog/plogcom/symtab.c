/*
 * Copyright (c) 2025 PCC Prolog Compiler
 *
 * Symbol table management for predicates
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "pass1.h"

/* Hash function for predicate names */
unsigned int hash_predicate(const char *name, int arity) {
	unsigned int hash = hash_string(name);
	hash = (hash * 31) + arity;
	return hash % 256;
}

/* Initialize symbol table */
void init_symtab(void) {
	int i;
	for (i = 0; i < 256; i++) {
		predicate_table[i] = NULL;
	}
}

/* Lookup predicate in symbol table */
struct predicate *lookup_predicate(char *name, int arity) {
	unsigned int hash = hash_predicate(name, arity);
	struct predicate *p = predicate_table[hash];

	while (p) {
		if (strcmp(p->name, name) == 0 && p->arity == arity)
			return p;
		p = p->next;
	}

	return NULL;
}

/* Define new predicate */
struct predicate *define_predicate(char *name, int arity) {
	struct predicate *p = lookup_predicate(name, arity);

	if (p)
		return p; /* Already defined */

	/* Create new predicate */
	p = malloc_check(sizeof(struct predicate));
	p->name = strdup_check(name);
	p->arity = arity;
	p->clauses = NULL;
	p->is_builtin = 0;
	p->is_dynamic = 0;
	p->is_multifile = 0;
	p->clause_count = 0;

	/* Add to hash table */
	unsigned int hash = hash_predicate(name, arity);
	p->next = predicate_table[hash];
	predicate_table[hash] = p;

	return p;
}

/* Add clause to predicate */
void add_predicate_clause(struct predicate *pred, struct clause *clause) {
	if (!pred || !clause)
		return;

	/* Append clause to end of clause list */
	if (!pred->clauses) {
		pred->clauses = clause;
	} else {
		struct clause *p = pred->clauses;
		while (p->next)
			p = p->next;
		p->next = clause;
	}

	pred->clause_count++;
}

/* Create fact clause */
struct clause *make_fact(struct term *head) {
	struct clause *c = malloc_check(sizeof(struct clause));
	c->head = head;
	c->body = NULL;
	c->lineno = lineno;
	c->next = NULL;
	return c;
}

/* Create rule clause */
struct clause *make_rule(struct term *head, struct term *body) {
	struct clause *c = malloc_check(sizeof(struct clause));
	c->head = head;
	c->body = body;
	c->lineno = lineno;
	c->next = NULL;
	return c;
}

/* Add clause to program */
void add_clause(struct clause *clause) {
	if (!clause || !clause->head)
		return;

	/* Extract predicate name and arity from head */
	char *name = NULL;
	int arity = 0;

	if (clause->head->type == TERM_ATOM) {
		name = clause->head->data.atom;
		arity = 0;
	} else if (clause->head->type == TERM_COMPOUND) {
		name = clause->head->data.compound.functor;
		arity = clause->head->data.compound.arity;
	} else {
		error("Invalid clause head");
		return;
	}

	/* Find or create predicate */
	struct predicate *pred = define_predicate(name, arity);

	/* Add clause to predicate */
	add_predicate_clause(pred, clause);

	/* Also add to global clause list */
	if (!clause_list) {
		clause_list = clause;
	} else {
		struct clause *p = clause_list;
		while (p->next)
			p = p->next;
		p->next = clause;
	}
}

/* Print clause */
void print_clause(FILE *fp, struct clause *c) {
	if (!c)
		return;

	print_term(fp, c->head);

	if (c->body) {
		fprintf(fp, " :- ");
		print_term(fp, c->body);
	}

	fprintf(fp, ".\n");
}

/* Print all clauses for a predicate */
static void print_predicate(FILE *fp, struct predicate *p) {
	if (!p)
		return;

	fprintf(fp, "\n%% Predicate: %s/%d", p->name, p->arity);
	if (p->is_builtin)
		fprintf(fp, " (built-in)");
	if (p->is_dynamic)
		fprintf(fp, " (dynamic)");
	if (p->is_multifile)
		fprintf(fp, " (multifile)");
	fprintf(fp, "\n");

	struct clause *c = p->clauses;
	while (c) {
		print_clause(fp, c);
		c = c->next;
	}
}

/* Dump symbol table */
void dump_symtab(void) {
	int i;
	for (i = 0; i < 256; i++) {
		struct predicate *p = predicate_table[i];
		while (p) {
			print_predicate(stderr, p);
			p = p->next;
		}
	}
}

/* Print program */
void print_program(FILE *fp) {
	fprintf(fp, "%% Prolog Program\n");
	fprintf(fp, "%% Generated by PCC Prolog Compiler\n\n");

	struct clause *c = clause_list;
	while (c) {
		print_clause(fp, c);
		c = c->next;
	}
}
