/*
 * Copyright (c) 2025 PCC Prolog Compiler
 *
 * Code generation
 * Generates C code, bytecode, or WAM instructions
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "pass1.h"

/* Forward declarations */
static void generate_predicate_c(FILE *fp, struct predicate *pred);

/* Generate C code for Prolog program */
void generate_c_code(FILE *fp) {
	fprintf(fp, "/*\n");
	fprintf(fp, " * Generated by PCC Prolog Compiler\n");
	fprintf(fp, " * Prolog runtime in C\n");
	fprintf(fp, " */\n\n");

	fprintf(fp, "#include <stdio.h>\n");
	fprintf(fp, "#include <stdlib.h>\n");
	fprintf(fp, "#include <string.h>\n");
	fprintf(fp, "#include <stdint.h>\n\n");

	/* Generate runtime structures */
	fprintf(fp, "/* Prolog runtime structures */\n");
	fprintf(fp, "typedef enum {\n");
	fprintf(fp, "    TERM_ATOM, TERM_VAR, TERM_INT, TERM_FLOAT,\n");
	fprintf(fp, "    TERM_STRING, TERM_COMPOUND, TERM_LIST, TERM_NIL\n");
	fprintf(fp, "} term_type_t;\n\n");

	fprintf(fp, "typedef struct term {\n");
	fprintf(fp, "    term_type_t type;\n");
	fprintf(fp, "    union {\n");
	fprintf(fp, "        char *atom;\n");
	fprintf(fp, "        int var_id;\n");
	fprintf(fp, "        long ival;\n");
	fprintf(fp, "        double fval;\n");
	fprintf(fp, "        char *str;\n");
	fprintf(fp, "        struct {\n");
	fprintf(fp, "            char *functor;\n");
	fprintf(fp, "            int arity;\n");
	fprintf(fp, "            struct term **args;\n");
	fprintf(fp, "        } compound;\n");
	fprintf(fp, "        struct {\n");
	fprintf(fp, "            struct term *head;\n");
	fprintf(fp, "            struct term *tail;\n");
	fprintf(fp, "        } cons;\n");
	fprintf(fp, "    } data;\n");
	fprintf(fp, "    struct term *binding; /* For variables */\n");
	fprintf(fp, "} term_t;\n\n");

	/* Generate runtime functions */
	fprintf(fp, "/* Runtime functions */\n");
	fprintf(fp, "term_t *make_atom(const char *name);\n");
	fprintf(fp, "term_t *make_var(int id);\n");
	fprintf(fp, "term_t *make_int(long val);\n");
	fprintf(fp, "term_t *make_float(double val);\n");
	fprintf(fp, "term_t *make_compound(const char *functor, int arity, term_t **args);\n");
	fprintf(fp, "term_t *make_list(term_t *head, term_t *tail);\n");
	fprintf(fp, "term_t *make_nil(void);\n");
	fprintf(fp, "int unify(term_t *t1, term_t *t2);\n");
	fprintf(fp, "term_t *deref(term_t *t);\n");
	fprintf(fp, "void print_term(term_t *t);\n\n");

	/* Generate predicate declarations */
	fprintf(fp, "/* Predicate declarations */\n");
	int i;
	for (i = 0; i < 256; i++) {
		struct predicate *p = predicate_table[i];
		while (p) {
			if (!p->is_builtin) {
				fprintf(fp, "int pred_%s_%d(", p->name, p->arity);
				int j;
				for (j = 0; j < p->arity; j++) {
					fprintf(fp, "term_t *arg%d", j);
					if (j < p->arity - 1)
						fprintf(fp, ", ");
				}
				fprintf(fp, ");\n");
			}
			p = p->next;
		}
	}
	fprintf(fp, "\n");

	/* Generate predicate implementations */
	fprintf(fp, "/* Predicate implementations */\n");
	for (i = 0; i < 256; i++) {
		struct predicate *p = predicate_table[i];
		while (p) {
			if (!p->is_builtin) {
				generate_predicate_c(fp, p);
			}
			p = p->next;
		}
	}

	/* Generate main function */
	fprintf(fp, "/* Main function */\n");
	fprintf(fp, "int main(int argc, char **argv) {\n");
	fprintf(fp, "    /* Initialize runtime */\n");
	fprintf(fp, "    \n");
	fprintf(fp, "    /* Execute goal if any */\n");
	fprintf(fp, "    \n");
	fprintf(fp, "    return 0;\n");
	fprintf(fp, "}\n");
}

/* Generate C code for a single predicate */
static void generate_predicate_c(FILE *fp, struct predicate *pred) {
	fprintf(fp, "\n/* Predicate: %s/%d */\n", pred->name, pred->arity);
	fprintf(fp, "int pred_%s_%d(", pred->name, pred->arity);

	int i;
	for (i = 0; i < pred->arity; i++) {
		fprintf(fp, "term_t *arg%d", i);
		if (i < pred->arity - 1)
			fprintf(fp, ", ");
	}
	fprintf(fp, ") {\n");

	/* Generate code for each clause */
	struct clause *c = pred->clauses;
	int clause_num = 0;

	while (c) {
		fprintf(fp, "    /* Clause %d */\n", ++clause_num);
		fprintf(fp, "    {\n");

		/* Generate unification for head */
		fprintf(fp, "        /* Try to unify with head */\n");

		/* Generate body execution */
		if (c->body) {
			fprintf(fp, "        /* Execute body */\n");
		}

		fprintf(fp, "        return 1; /* Success */\n");
		fprintf(fp, "    }\n");

		c = c->next;
	}

	fprintf(fp, "    return 0; /* Fail */\n");
	fprintf(fp, "}\n");
}

/* Generate bytecode */
void generate_bytecode(FILE *fp) {
	fprintf(fp, "# PCC Prolog Bytecode\n");
	fprintf(fp, "# Version 1.0\n\n");

	/* Generate bytecode instructions */
	int i;
	for (i = 0; i < 256; i++) {
		struct predicate *p = predicate_table[i];
		while (p) {
			if (!p->is_builtin) {
				fprintf(fp, "\n.predicate %s/%d\n", p->name, p->arity);

				struct clause *c = p->clauses;
				while (c) {
					fprintf(fp, ".clause\n");
					/* Generate bytecode for clause */
					fprintf(fp, "  ; clause body\n");
					c = c->next;
				}
			}
			p = p->next;
		}
	}
}

/* Generate WAM (Warren Abstract Machine) code */
void generate_wam(FILE *fp) {
	fprintf(fp, "% PCC Prolog WAM Code\n");
	fprintf(fp, "% Warren Abstract Machine Instructions\n\n");

	/* Generate WAM instructions */
	int i;
	for (i = 0; i < 256; i++) {
		struct predicate *p = predicate_table[i];
		while (p) {
			if (!p->is_builtin) {
				fprintf(fp, "\n%% Predicate: %s/%d\n", p->name, p->arity);
				fprintf(fp, "predicate(%s, %d).\n", p->name, p->arity);

				struct clause *c = p->clauses;
				int clause_num = 0;
				while (c) {
					fprintf(fp, "\n%% Clause %d\n", ++clause_num);
					fprintf(fp, "label(%s_%d_clause_%d):\n",
					        p->name, p->arity, clause_num);

					/* Generate WAM instructions */
					fprintf(fp, "  try_me_else(%s_%d_clause_%d)\n",
					        p->name, p->arity, clause_num + 1);

					/* Head unification */
					fprintf(fp, "  %% Unify head\n");

					/* Body execution */
					if (c->body) {
						fprintf(fp, "  %% Execute body\n");
						fprintf(fp, "  execute(body)\n");
					}

					fprintf(fp, "  proceed\n");

					c = c->next;
				}

				fprintf(fp, "label(%s_%d_fail):\n", p->name, p->arity);
				fprintf(fp, "  fail\n");
			}
			p = p->next;
		}
	}
}

/* Generic code generation dispatcher */
void generate_code(void) {
	/* This is called from main.c with specific format */
}
