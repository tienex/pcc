/*	$Id$	*/
/*
 * Copyright (c) 2025 JavaScript Backend
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * JavaScript ES2025 code generator
 * Supports ES3/ES5/ES6/ES2015-2025 with extensions from ActionScript,
 * TypeScript, CoffeeScript, and LiveScript
 */

#include "pass1.h"

#ifdef LANG_CXX
#define P1ND NODE
#define p1alloc talloc
#define p1nfree nfree
#define p1fwalk fwalk
#define p1tcopy ccopy
#endif

static int js_header_emitted = 0;
static int in_function = 0;

/* ES version and extension flags */
extern int mjesmodel;
extern int mjesmodule;

/*
 * Helper: Get JavaScript type annotation (TypeScript mode)
 */
static char *
js_typename(TWORD t)
{
	if (!(mjesmodel & MJES_TYPESCRIPT))
		return "";

	if (ISPTR(t))
		return ": any"; /* TypeScript any for pointers */

	switch (BTYPE(t)) {
	case CHAR:
	case SCHAR:
	case UCHAR:
	case SHORT:
	case USHORT:
	case INT:
	case UNSIGNED:
		return ": number";
	case LONG:
	case ULONG:
		if (mjesmodel & MJES_ES2020)
			return ": bigint"; /* ES2020+ BigInt */
		return ": number";
	case LONGLONG:
	case ULONGLONG:
		if (mjesmodel & MJES_ES2020)
			return ": bigint";
		return ": number";
	case FLOAT:
	case DOUBLE:
	case LDOUBLE:
		return ": number";
	case VOID:
		return ": void";
	case BOOL:
	case UNDEF:
		return ": boolean";
	default:
		return ": any";
	}
}

/*
 * Helper: Get variable declaration keyword based on ES version
 */
static char *
js_vardecl(void)
{
	if (mjesmodel & MJES_ES6)
		return "let"; /* ES6+ uses 'let' for block scope */
	else if (mjesmodel & MJES_ES5)
		return "var"; /* ES5 uses 'var' */
	else
		return "var"; /* ES3 fallback */
}

/*
 * Helper: Get constant declaration keyword based on ES version
 */
static char *
js_constdecl(void)
{
	if (mjesmodel & MJES_ES6)
		return "const"; /* ES6+ uses 'const' */
	else
		return "var"; /* ES5/ES3 fallback to var */
}

/*
 * Emit JavaScript file header with strict mode and module system
 */
static void
emit_js_header(void)
{
	if (js_header_emitted)
		return;
	js_header_emitted = 1;

	printf("/**\n");
	printf(" * Generated by PCC JavaScript backend\n");

	/* Emit ES version info */
	if (mjesmodel & MJES_ES2025)
		printf(" * Target: ES2025\n");
	else if (mjesmodel & MJES_ES2024)
		printf(" * Target: ES2024\n");
	else if (mjesmodel & MJES_ES2023)
		printf(" * Target: ES2023\n");
	else if (mjesmodel & MJES_ES6)
		printf(" * Target: ES2015 (ES6)\n");
	else if (mjesmodel & MJES_ES5)
		printf(" * Target: ES5\n");
	else
		printf(" * Target: ES3\n");

	/* Emit extension info */
	if (mjesmodel & MJES_TYPESCRIPT)
		printf(" * Extensions: TypeScript\n");
	if (mjesmodel & MJES_ACTIONSCRIPT)
		printf(" * Extensions: ActionScript\n");
	if (mjesmodel & MJES_COFFEESCRIPT)
		printf(" * Extensions: CoffeeScript\n");
	if (mjesmodel & MJES_LIVESCRIPT)
		printf(" * Extensions: LiveScript\n");

	printf(" */\n\n");

	/* Strict mode for ES5+ */
	if (mjesmodel & MJES_ES5)
		printf("'use strict';\n\n");

	/* Module system setup */
	switch (mjesmodule) {
	case MJES_MODULE_ESM:
		/* ES6 modules - export declarations individually */
		break;
	case MJES_MODULE_CJS:
		/* CommonJS - will use module.exports */
		break;
	case MJES_MODULE_AMD:
		printf("define(function() {\n");
		break;
	case MJES_MODULE_UMD:
		printf("(function (root, factory) {\n");
		printf("  if (typeof define === 'function' && define.amd) {\n");
		printf("    define([], factory);\n");
		printf("  } else if (typeof module === 'object' && module.exports) {\n");
		printf("    module.exports = factory();\n");
		printf("  } else {\n");
		printf("    root.pcc = factory();\n");
		printf("  }\n");
		printf("}(typeof self !== 'undefined' ? self : this, function () {\n");
		break;
	case MJES_MODULE_NONE:
	default:
		/* Global scope - no wrapper */
		break;
	}
}

/*
 * Emit module footer
 */
void
ejobcode(int flag)
{
	if (!js_header_emitted)
		return;

	switch (mjesmodule) {
	case MJES_MODULE_AMD:
		printf("});\n");
		break;
	case MJES_MODULE_UMD:
		printf("}));\n");
		break;
	case MJES_MODULE_CJS:
		/* Exports handled per-function */
		break;
	case MJES_MODULE_ESM:
		/* Exports handled per-function */
		break;
	case MJES_MODULE_NONE:
	default:
		break;
	}
}

/*
 * Cause the alignment to become a multiple of n
 * JavaScript has no alignment requirements
 */
void
defalign(int n)
{
	/* No-op for JavaScript */
}

/*
 * Print out segment name
 * JavaScript doesn't have segments, use comments
 */
void
setseg(int seg, char *name)
{
	emit_js_header();

	switch (seg) {
	case PROG:
		printf("\n// --- Code Section ---\n");
		break;
	case DATA:
	case LDATA:
		printf("\n// --- Data Section ---\n");
		break;
	case UDATA:
		printf("\n// --- BSS Section (uninitialized) ---\n");
		break;
	case RDATA:
		printf("\n// --- Read-Only Data Section ---\n");
		break;
	case STRNG:
		printf("\n// --- String Constants ---\n");
		break;
	default:
		if (name)
			printf("\n// --- Section: %s ---\n", name);
		break;
	}
}

/*
 * Define location for data/function
 */
void
defloc(struct symtab *sp)
{
	char *name = getexname(sp);
	char *typeann = js_typename(sp->stype);

	if (ISFTN(sp->stype)) {
		/* Function declaration */
		if (sp->sclass == EXTDEF) {
			/* External function - will be defined later */
			if (mjesmodule == MJES_MODULE_ESM)
				printf("export ");

			if (mjesmodel & MJES_ES6) {
				/* ES6 arrow function or function keyword */
				printf("function %s", name);
			} else if (mjesmodel & MJES_TYPESCRIPT) {
				/* TypeScript function with type annotations */
				printf("function %s", name);
			} else {
				/* ES5/ES3 function */
				printf("function %s", name);
			}
		} else {
			/* Static/local function */
			if (mjesmodel & MJES_ES6)
				printf("%s %s", js_constdecl(), name);
			else
				printf("var %s", name);
		}
		return;
	}

	/* Variable declaration */
	if (sp->sclass == EXTDEF) {
		if (mjesmodule == MJES_MODULE_ESM)
			printf("export ");
		printf("%s %s%s;\n", js_vardecl(), name, typeann);
	} else if (sp->sclass == STATIC) {
		printf("%s %s%s;\n", js_vardecl(), name, typeann);
	}
}

/*
 * Make a common declaration for id
 */
void
defzero(struct symtab *sp)
{
	char *name = getexname(sp);
	char *typeann = js_typename(sp->stype);

	if (sp->sclass == STATIC) {
		if (sp->slevel == 0) {
			printf("%s %s%s = 0;\n", js_vardecl(), name, typeann);
		} else {
			printf("%s " LABFMT "%s = 0;\n", js_vardecl(), sp->soffset, typeann);
		}
	} else {
		printf("%s %s%s = 0;\n", js_vardecl(), name, typeann);
	}
}

/*
 * Code for the end of a function
 */
void
efcode(void)
{
	if (!in_function)
		return;

	printf("}\n");
	in_function = 0;

	/* For CommonJS, export the function */
	/* This is handled per-function basis */
}

/*
 * Code for the beginning of a function
 */
void
bfcode(struct symtab **a, int n)
{
	int i;
	char *name;

	emit_js_header();

	/* Function parameters */
	printf("(");
	for (i = 0; i < n; i++) {
		name = a[i]->sname ? a[i]->sname : exname(a[i]->soffset);

		if (i > 0)
			printf(", ");

		printf("%s", name);

		/* TypeScript type annotations */
		if (mjesmodel & MJES_TYPESCRIPT) {
			printf("%s", js_typename(a[i]->stype));
		}
	}
	printf(")");

	/* TypeScript return type annotation */
	if (mjesmodel & MJES_TYPESCRIPT) {
		if (cftnsp)
			printf("%s", js_typename(cftnsp->stype));
	}

	/* Function body start */
	printf(" {\n");
	in_function = 1;

	/* ES6 strict mode is already global */
	/* Local variable declarations will be emitted as needed */
}

/*
 * Called before arg evaluation for a function call
 */
void
inargsetup(void)
{
	/* JavaScript handles arguments automatically */
}

/*
 * Called before function epilogue
 */
void
fixit(void)
{
	/* Nothing needed for JavaScript */
}

/*
 * Define a label
 */
void
deflab(int label)
{
	printf(LABFMT ":\n", label);
}

/*
 * Define a name (variable or function)
 */
void
defnam(struct symtab *sp)
{
	char *name = getexname(sp);
	TWORD t = sp->stype;
	char *typeann = js_typename(t);

	if (ISFTN(t))
		return; /* Functions handled by defloc/bfcode */

	/* Variable definition */
	if (sp->sclass == EXTDEF) {
		if (mjesmodule == MJES_MODULE_ESM)
			printf("export ");
		printf("%s %s%s;\n", js_vardecl(), name, typeann);
	} else if (sp->sclass == EXTERN) {
		/* External declaration - comment only in JS */
		printf("// extern %s%s\n", name, typeann);
	} else if (sp->sclass == STATIC) {
		printf("%s %s%s;\n", js_vardecl(), name, typeann);
	}
}

/*
 * JavaScript helper functions for operators and constructs
 */

/*
 * Emit integer division (JavaScript / is float division)
 */
void
js_emit_intdiv(void)
{
	if (mjesmodel & MJES_ES6) {
		printf("Math.trunc"); /* ES6 Math.trunc for integer division */
	} else {
		printf("~~"); /* ES5 double bitwise NOT for int conversion */
	}
}

/*
 * Emit modulo operation
 */
void
js_emit_mod(void)
{
	printf("%%"); /* JavaScript % operator */
}

/*
 * Emit bitwise operations (same in all ES versions)
 */
void
js_emit_bitop(char *op)
{
	printf("%s", op); /* &, |, ^, <<, >>, >>> */
}

/*
 * Emit logical operations
 */
void
js_emit_logop(char *op)
{
	printf("%s", op); /* &&, ||, ! */
}

/*
 * Emit comparison operations
 */
void
js_emit_cmpop(char *op)
{
	/* Use === and !== for ES5+ (strict equality) */
	if (mjesmodel & MJES_ES5) {
		if (strcmp(op, "==") == 0)
			printf("===");
		else if (strcmp(op, "!=") == 0)
			printf("!==");
		else
			printf("%s", op);
	} else {
		printf("%s", op);
	}
}

/*
 * Emit typeof operator
 */
void
js_emit_typeof(char *expr)
{
	printf("typeof %s", expr);
}

/*
 * Emit instanceof operator
 */
void
js_emit_instanceof(char *expr, char *type)
{
	printf("%s instanceof %s", expr, type);
}

/*
 * Emit optional chaining (ES2020+)
 */
void
js_emit_optional_chain(char *base, char *prop)
{
	if (mjesmodel & MJES_ES2020) {
		printf("%s?.%s", base, prop);
	} else {
		/* Fallback: base && base.prop */
		printf("%s && %s.%s", base, base, prop);
	}
}

/*
 * Emit nullish coalescing (ES2020+)
 */
void
js_emit_nullish_coalesce(char *left, char *right)
{
	if (mjesmodel & MJES_ES2020) {
		printf("%s ?? %s", left, right);
	} else {
		/* Fallback: (left !== null && left !== undefined) ? left : right */
		printf("(%s !== null && %s !== undefined) ? %s : %s",
		       left, left, left, right);
	}
}

/*
 * Emit BigInt literal (ES2020+)
 */
void
js_emit_bigint(long long val)
{
	if (mjesmodel & MJES_ES2020) {
		printf("%lldn", val);
	} else {
		/* Fallback: use Number or string representation */
		printf("%lld", val);
	}
}

/*
 * Emit class definition (ES6+ or ES5 prototype)
 */
void
js_emit_class_start(char *name, char *superclass)
{
	if (mjesmodel & MJES_ES6) {
		/* ES6 class syntax */
		printf("class %s", name);
		if (superclass)
			printf(" extends %s", superclass);
		printf(" {\n");
	} else {
		/* ES5 prototype-based */
		printf("function %s() {\n", name);
		/* Constructor body */
	}
}

void
js_emit_class_end(char *name, char *superclass)
{
	if (mjesmodel & MJES_ES6) {
		printf("}\n");
	} else {
		/* ES5 prototype chain setup */
		printf("}\n");
		if (superclass) {
			printf("%s.prototype = Object.create(%s.prototype);\n",
			       name, superclass);
			printf("%s.prototype.constructor = %s;\n", name, name);
		}
	}
}

/*
 * Emit async function (ES2017+)
 */
void
js_emit_async_function(char *name)
{
	if (mjesmodel & MJES_ES2017) {
		printf("async function %s", name);
	} else {
		/* Fallback: return Promise */
		printf("function %s", name);
		/* Note: Implementation would need to wrap in Promise */
	}
}

/*
 * Emit await expression (ES2017+)
 */
void
js_emit_await(char *expr)
{
	if (mjesmodel & MJES_ES2017) {
		printf("await %s", expr);
	} else {
		/* Fallback: use .then() */
		printf("%s.then(function(result) { return result; })", expr);
	}
}

/*
 * Emit arrow function (ES6+)
 */
void
js_emit_arrow_function(char *params, char *body)
{
	if (mjesmodel & MJES_ES6) {
		printf("(%s) => %s", params, body);
	} else {
		/* ES5 fallback: regular function */
		printf("function(%s) { return %s; }", params, body);
	}
}

/*
 * Emit template literal (ES6+)
 */
void
js_emit_template_literal(char *str)
{
	if (mjesmodel & MJES_ES6) {
		printf("`%s`", str);
	} else {
		/* ES5 fallback: string concatenation */
		printf("\"%s\"", str);
	}
}

/*
 * Emit destructuring assignment (ES6+)
 */
void
js_emit_destructure_array(char *vars, char *array)
{
	if (mjesmodel & MJES_ES6) {
		printf("%s [%s] = %s;\n", js_vardecl(), vars, array);
	} else {
		/* ES5 fallback: manual assignment */
		/* This would need more complex handling */
		printf("/* destructuring not supported in ES5 */\n");
	}
}

/*
 * Emit spread operator (ES6+)
 */
void
js_emit_spread(char *array)
{
	if (mjesmodel & MJES_ES6) {
		printf("...%s", array);
	} else {
		/* ES5 fallback: Array.prototype.slice.call() */
		printf("Array.prototype.slice.call(%s)", array);
	}
}

/*
 * Emit for-of loop (ES6+)
 */
void
js_emit_for_of(char *varname, char *iterable)
{
	if (mjesmodel & MJES_ES6) {
		printf("for (%s %s of %s) {\n", js_vardecl(), varname, iterable);
	} else {
		/* ES5 fallback: for loop with index */
		printf("for (var _i = 0; _i < %s.length; _i++) {\n", iterable);
		printf("  var %s = %s[_i];\n", varname, iterable);
	}
}

/*
 * Emit Map/Set (ES6+)
 */
void
js_emit_map_new(void)
{
	if (mjesmodel & MJES_ES6) {
		printf("new Map()");
	} else {
		/* ES5 fallback: object */
		printf("{}");
	}
}

void
js_emit_set_new(void)
{
	if (mjesmodel & MJES_ES6) {
		printf("new Set()");
	} else {
		/* ES5 fallback: array */
		printf("[]");
	}
}

/*
 * Emit Promise (ES6+)
 */
void
js_emit_promise(char *executor)
{
	if (mjesmodel & MJES_ES6) {
		printf("new Promise(%s)", executor);
	} else {
		/* ES5 fallback: would need Promise polyfill */
		printf("/* Promise requires polyfill for ES5 */");
	}
}

/*
 * CoffeeScript/LiveScript extension: existential operator
 */
void
js_emit_existential(char *expr)
{
	if (mjesmodel & (MJES_COFFEESCRIPT | MJES_LIVESCRIPT)) {
		/* expr? becomes (typeof expr !== 'undefined' && expr !== null) */
		printf("(typeof %s !== 'undefined' && %s !== null)", expr, expr);
	} else {
		printf("%s", expr);
	}
}

/*
 * LiveScript extension: function composition
 */
void
js_emit_function_compose(char *f, char *g)
{
	if (mjesmodel & MJES_LIVESCRIPT) {
		/* f >> g becomes function(x) { return g(f(x)); } */
		printf("(function(x) { return %s(%s(x)); })", g, f);
	} else {
		printf("/* function composition not supported */");
	}
}

/*
 * TypeScript: interface declaration
 */
void
js_emit_interface(char *name, char *body)
{
	if (mjesmodel & MJES_TYPESCRIPT) {
		printf("interface %s %s\n", name, body);
	} else {
		/* Skip interfaces in pure JavaScript */
		printf("// interface %s (TypeScript only)\n", name);
	}
}

/*
 * TypeScript: type alias
 */
void
js_emit_type_alias(char *name, char *type)
{
	if (mjesmodel & MJES_TYPESCRIPT) {
		printf("type %s = %s;\n", name, type);
	} else {
		printf("// type alias (TypeScript only)\n");
	}
}

/*
 * ActionScript: package/namespace
 */
void
js_emit_namespace(char *name)
{
	if (mjesmodel & MJES_ACTIONSCRIPT) {
		/* Use object as namespace */
		printf("%s %s = %s || {};\n", js_vardecl(), name, name);
	} else if (mjesmodel & MJES_TYPESCRIPT) {
		printf("namespace %s {\n", name);
	} else {
		/* Regular object */
		printf("%s %s = {};\n", js_vardecl(), name);
	}
}
