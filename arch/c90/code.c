/*	$Id$	*/
/*
 * Copyright (c) 2025 C90 Backend Generator
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "pass1.h"

/*
 * C90 code generator - generates C code instead of assembly
 */

static int c90_header_emitted = 0;

/* Forward declarations */
extern int mcc90model;

/*
 * Helper: Get C type name for a TWORD
 */
static char *
c90_typename(TWORD t, int *needs_unsigned)
{
	*needs_unsigned = 0;

	if (ISPTR(t))
		return "void *";

	switch (BTYPE(t)) {
	case CHAR:
	case SCHAR:
		return "char";
	case UCHAR:
		*needs_unsigned = 1;
		return "char";
	case SHORT:
		return "short";
	case USHORT:
		*needs_unsigned = 1;
		return "short";
	case INT:
		return "int";
	case UNSIGNED:
		*needs_unsigned = 1;
		return "int";
	case LONG:
		return "long";
	case ULONG:
		*needs_unsigned = 1;
		return "long";
	case LONGLONG:
		return "long long";
	case ULONGLONG:
		*needs_unsigned = 1;
		return "long long";
	case FLOAT:
		return "float";
	case DOUBLE:
		return "double";
	case LDOUBLE:
		return "long double";
	case VOID:
		return "void";
	default:
		return "int"; /* fallback */
	}
}

/*
 * Emit C90 file header with necessary includes
 */
static void
emit_c90_header(void)
{
	if (c90_header_emitted)
		return;
	c90_header_emitted = 1;

	printf("/* Generated by PCC C90 backend");
	if (mcc90model & MCC90_16BIT)
		printf(" (16-bit mode)");
	else if (mcc90model & MCC90_64BIT)
		printf(" (64-bit mode)");
	else if (mcc90model & MCC90_SEGMENTED)
		printf(" (segmented mode)");
	else
		printf(" (32-bit mode)");
	printf(" */\n\n");

	/* Standard includes */
	printf("#include <stddef.h>  /* size_t, ptrdiff_t, NULL */\n");
	printf("#include <limits.h>  /* INT_MAX, LONG_MAX, etc. */\n");
	printf("#include <float.h>   /* FLT_MAX, DBL_MAX, etc. */\n");

	/* Compatibility definitions */
	if (mcc90model & MCC90_16BIT) {
		printf("\n/* 16-bit mode type definitions */\n");
		printf("typedef int int16_t;\n");
		printf("typedef unsigned int uint16_t;\n");
		printf("typedef long int32_t;\n");
		printf("typedef unsigned long uint32_t;\n");
	} else if (mcc90model & MCC90_64BIT) {
		printf("\n/* 64-bit mode type definitions */\n");
		printf("typedef long int64_t;\n");
		printf("typedef unsigned long uint64_t;\n");
	}

	printf("\n");
}

/*
 * Print out segment name (translated to C constructs)
 */
void
setseg(int seg, char *name)
{
	emit_c90_header();

	switch (seg) {
	case PROG:
		/* Code segment - no special handling in C */
		printf("\n/* .text section */\n");
		break;
	case DATA:
	case LDATA:
		printf("\n/* .data section */\n");
		break;
	case UDATA:
		printf("\n/* .bss section */\n");
		break;
	case RDATA:
		printf("\n/* .rodata section */\n");
		break;
	case STRNG:
		printf("\n/* string constants */\n");
		break;
	default:
		if (name)
			printf("\n/* section: %s */\n", name);
		break;
	}
}

#ifdef MACHOABI
void
defalign(int al)
{
	/* Alignment is implicit in C90 */
}
#endif

/*
 * Define location for data/function
 */
void
defloc(struct symtab *sp)
{
	char *name = getexname(sp);

	if (sp->sclass == EXTDEF) {
		/* Will be defined later as actual C declaration */
	}
	/* Symbol definition handled in C declaration syntax */
}

/*
 * Code for the end of a function
 */
void
efcode(void)
{
	/* Function epilogue is handled by local2.c */
}

/*
 * Beginning of file
 */
void
bfcode(struct symtab **a, int n)
{
	emit_c90_header();
}

/*
 * End of file
 */
void
ejobcode(int flag)
{
	/* Nothing special needed */
}

/*
 * Called before arg evaluation for a function call
 */
void
inargsetup(void)
{
	/* Handled by C function call syntax */
}

/*
 * Called before function epilogue
 */
void
fixit(void)
{
	/* Nothing needed */
}

/*
 * Initialization code for a function
 */
void
bfunc(struct symtab *sp)
{
	/* Function prologue handled in local2.c */
}

/*
 * Called after function body is compiled
 */
void
efunc(void)
{
	/* Function epilogue handled in local2.c */
}

/*
 * C90 directive abstraction functions (like libx86asm for assembly)
 */

/* Declare an external symbol */
void
c90_declare_external(char *name, TWORD type)
{
	int needs_unsigned;
	char *typename = c90_typename(type, &needs_unsigned);

	printf("extern ");
	if (needs_unsigned)
		printf("unsigned ");
	printf("%s %s;\n", typename, name);
}

/* Declare a static symbol */
void
c90_declare_static(char *name, TWORD type)
{
	int needs_unsigned;
	char *typename = c90_typename(type, &needs_unsigned);

	printf("static ");
	if (needs_unsigned)
		printf("unsigned ");
	printf("%s %s;\n", typename, name);
}

/* Declare a weak symbol (C90 compatible comment) */
void
c90_declare_weak(char *name)
{
	printf("/* weak symbol: %s */\n", name);
}

/* Create symbol alias (C90 compatible via macro) */
void
c90_create_alias(char *from, char *to)
{
	printf("#define %s %s  /* alias */\n", from, to);
}

/*
 * Define a name (variable or function)
 */
void
defnam(struct symtab *sp)
{
	char *name = getexname(sp);
	TWORD t = sp->stype;

	/* Emit C declaration */
	if (ISFTN(t)) {
		/* Function declaration handled in prologue */
	} else {
		/* Variable declaration */
		if (sp->sclass == EXTDEF) {
			c90_declare_external(name, t);
		} else if (sp->sclass == STATIC) {
			c90_declare_static(name, t);
		} else {
			int needs_unsigned;
			char *typename = c90_typename(t, &needs_unsigned);

			if (needs_unsigned)
				printf("unsigned ");
			printf("%s %s;\n", typename, name);
		}
	}
}

/*
 * Initialize a local variable
 */
void
defzero(struct symtab *sp)
{
	char *name = getexname(sp);
	printf("\t%s = 0;\n", name);
}
